diff --git a/src/include/robin_hood.h b/src/include/robin_hood.h
index 0af031f..0317dab 100644
--- a/src/include/robin_hood.h
+++ b/src/include/robin_hood.h
@@ -405,7 +405,11 @@ public:
         while (mListForFree) {
             T* tmp = *mListForFree;
             ROBIN_HOOD_LOG("std::free")
+#if _MSC_VER
+            _aligned_free(mListForFree);
+#else
             std::free(mListForFree);
+#endif
             mListForFree = reinterpret_cast_no_cast_align_warning<T**>(tmp);
         }
         mHead = nullptr;
@@ -441,7 +445,11 @@ public:
         if (numBytes < ALIGNMENT + ALIGNED_SIZE) {
             // not enough data for at least one element. Free and return.
             ROBIN_HOOD_LOG("std::free")
+#if _MSC_VER
+            _aligned_free(ptr);
+#else
             std::free(ptr);
+#endif
         } else {
             ROBIN_HOOD_LOG("add to buffer")
             add(ptr, numBytes);
@@ -508,9 +516,13 @@ private:
 
         // alloc new memory: [prev |T, T, ... T]
         size_t const bytes = ALIGNMENT + ALIGNED_SIZE * numElementsToAlloc;
-        ROBIN_HOOD_LOG("std::malloc " << bytes << " = " << ALIGNMENT << " + " << ALIGNED_SIZE
+        ROBIN_HOOD_LOG("std::aligned_alloc " << bytes << " = " << ALIGNMENT << " + " << ALIGNED_SIZE
                                       << " * " << numElementsToAlloc)
-        add(assertNotNull<std::bad_alloc>(std::malloc(bytes)), bytes);
+#if _MSC_VER
+        add(assertNotNull<std::bad_alloc>(_aligned_malloc(bytes, ALIGNMENT)), bytes);
+#else
+        add(assertNotNull<std::bad_alloc>(std::aligned_alloc(ALIGNMENT, bytes)), bytes);
+#endif
         return mHead;
     }
 
@@ -547,7 +559,11 @@ struct NodeAllocator<T, MinSize, MaxSize, true> {
     // we are not using the data, so just free it.
     void addOrFree(void* ptr, size_t ROBIN_HOOD_UNUSED(numBytes) /*unused*/) noexcept {
         ROBIN_HOOD_LOG("std::free")
+#if _MSC_VER
+        _aligned_free(ptr);
+#else
         std::free(ptr);
+#endif
     }
 };
 
@@ -1594,7 +1610,11 @@ public:
                                           << numElementsWithBuffer << ")")
             mHashMultiplier = o.mHashMultiplier;
             mKeyVals = static_cast<Node*>(
+#if _MSC_VER
+                detail::assertNotNull<std::bad_alloc>(_aligned_malloc(numBytesTotal, 16)));
+#else
                 detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));
+#endif
             // no need for calloc because clonData does memcpy
             mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);
             mNumElements = o.mNumElements;
@@ -1643,7 +1663,11 @@ public:
             if (0 != mMask) {
                 // only deallocate if we actually have data!
                 ROBIN_HOOD_LOG("std::free")
+#if _MSC_VER
+                _aligned_free(mKeyVals);
+#else
                 std::free(mKeyVals);
+#endif
             }
 
             auto const numElementsWithBuffer = calcNumElementsWithBuffer(o.mMask + 1);
@@ -1651,7 +1675,11 @@ public:
             ROBIN_HOOD_LOG("std::malloc " << numBytesTotal << " = calcNumBytesTotal("
                                           << numElementsWithBuffer << ")")
             mKeyVals = static_cast<Node*>(
+#if _MSC_VER
+                detail::assertNotNull<std::bad_alloc>(_aligned_malloc(numBytesTotal, 16)));
+#else
                 detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));
+#endif
 
             // no need for calloc here because cloneData performs a memcpy.
             mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);
@@ -2240,7 +2268,11 @@ private:
             if (oldKeyVals != reinterpret_cast_no_cast_align_warning<Node*>(&mMask)) {
                 // don't destroy old data: put it into the pool instead
                 if (forceFree) {
+#if _MSC_VER
+                    _aligned_free(oldKeyVals);
+#else
                     std::free(oldKeyVals);
+#endif
                 } else {
                     DataPool::addOrFree(oldKeyVals, calcNumBytesTotal(oldMaxElementsWithBuffer));
                 }
@@ -2327,7 +2359,11 @@ private:
         ROBIN_HOOD_LOG("std::calloc " << numBytesTotal << " = calcNumBytesTotal("
                                       << numElementsWithBuffer << ")")
         mKeyVals = reinterpret_cast<Node*>(
+#if _MSC_VER
+            detail::assertNotNull<std::bad_alloc>(_aligned_malloc(numBytesTotal, 16)));
+#else
             detail::assertNotNull<std::bad_alloc>(std::malloc(numBytesTotal)));
+#endif
         mInfo = reinterpret_cast<uint8_t*>(mKeyVals + numElementsWithBuffer);
         std::memset(mInfo, 0, numBytesTotal - numElementsWithBuffer * sizeof(Node));
 
@@ -2476,7 +2512,11 @@ private:
         // [-Werror=free-nonheap-object]
         if (mKeyVals != reinterpret_cast_no_cast_align_warning<Node*>(&mMask)) {
             ROBIN_HOOD_LOG("std::free")
+#if _MSC_VER
+            _aligned_free(mKeyVals);
+#else
             std::free(mKeyVals);
+#endif
         }
     }
 

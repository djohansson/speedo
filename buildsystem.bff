#once

.BuildRootPath = '$_WORKING_DIR_$' // should be '$_CURRENT_BFF_DIR_$' but that seems broken...
.IntermediateFilePath = '$BuildRootPath$/build.intermediate'
.BuildOutputPath = '$BuildRootPath$/build.output'

.ProjectCommon = 
[
    .EmptyString = ''
    
    .ProjectType = 'vcxproj'
	.ProjectBuildCommand = 'cd ^$(SolutionDir) &amp; fbuild -ide -dist -cache ^$(ProjectName)-^$(Configuration)'
	.ProjectRebuildCommand = 'cd ^$(SolutionDir) &amp; fbuild -ide -dist -cache -clean ^$(ProjectName)-^$(Configuration)'
	.ProjectCleanCommand = 'cd ^$(SolutionDir) &amp; fbuild -ide Clean-^$(ProjectName)-^$(Configuration)'
	.ProjectBasePath  = '$BuildRootPath$'
	.OutputDirectory = '$BuildOutputPath$'
	.IntermediateDirectory = '$IntermediateFilePath$'
	.Platform = 'x64'
	.PlatformToolset = 'llvm'
	.Dependencies = { 'none-vcxproj' }
    
    .PreBuildDependencies = { }
	.DependencyObjectLists = { }
	.DependencyLibraries = { }
	.DependencyDLLs = { }
    .DependencyExecutables = { }
    .DependencyTasks = { }
    .UnityInputPath = { }
	.UnityInputPattern = '*.cpp'
    .UnityInputFiles = { }
    //.UnityInputExcludedFiles = { }
    .CompilerInputPath = { }
    .CompilerInputPattern = '*.cpp'
    .CompilerInputFiles = { }
    //.CompilerInputExcludedFiles = { }
    .OutputFilePrefix = ''
	.OutputFileSuffix = ''
]	

.UnityCommon = 
[
	.UnityOutputPath = '$IntermediateFilePath$'
]

.ObjectListCommon = 
[
	Using(.UnityCommon)
    Using(.ProjectCommon)

    .ProjectType = 'obj'
    .CompilerInputUnity = { }
	.ConfigDependentCompilerOptions = { }
    .UseConfigDependentInputPath = false
]

.LibraryCommon = 
[
	Using(.ObjectListCommon)

    .ProjectType = 'lib'
	.OutputFilePrefix = .LibPrefix
	.OutputFileSuffix = .LibSuffix
]

.DllCommon = 
[
	Using(.ProjectCommon)

    .ProjectType = 'dll'
	.Libraries = { }
	.OutputFilePrefix = .DllPrefix
	.OutputFileSuffix = .DllSuffix
]

.ExecutableCommon = 
[
	Using(.ProjectCommon)

    .ProjectType = 'exe'
	.Libraries = { }
	.OutputFilePrefix = ''
	.OutputFileSuffix = .ExeSuffix
]

.TestCommon = 
[
	Using(.ProjectCommon)

    .ProjectType = 'test'
    .TestWorkingDir = ''
    .TestOutputName = ''
]

.TaskCommon = 
[
	Using(.ProjectCommon)
    
    .ProjectType = 'task'
    .ExecExecutable = ''
    .ExecWorkingDir = ''
	.ExecOutputName = ''
]

.GlobalContext =
[
    .Targets = { }
    .ReturnValues = { }
    .ProjectConfigs = { }
    .ProjectNames = { }
 	// .SolutionDependencies = { }
    // .SolutionFolders = { }
]

function PrintArray(.ArrayName .Array)
{
    ForEach(.Object in .Array)
	{
        Print('$ArrayName$:$Object$')
    }
}

function AddUnities(.UnityObject)
{
    Using(.UnityObject)

    ^ReturnValues = { }
        
    ForEach (.Unity in .CompilerInputUnity)
    {
        If(.Unity not in .Targets)
	    {
            Print('AddUnities:$Unity$')
            Unity('$Unity$') {}
            ^Targets + .Unity
        }

        ^ReturnValues + '$Unity$'
    }
}

function AddObjectList(.ObjectList .CompilerConfig)
{
    .LocalObjectList = 
    [
        Using(.ObjectList)
        Using(.CompilerConfig)

        .ObjectListName = '$Name$-obj-$ConfigName$'

        ForEach(.Task in .DependencyTasks)
        {
            ^ReturnValues = { }
            AddTask(.Task .CompilerConfig)
            ^PreBuildDependencies + .ReturnValues
        }

        .CompilerOptions + ' -DPROFILING_ENABLED=$ProfilingEnabled$'
            + .ObjectListCompilerOptions

        ForEach(.CompilerOption in .ConfigDependentCompilerOptions)
        {
            ^CompilerOptions + '$CompilerOption$/$ConfigName$'
            ^CompilerOptions + '$CompilerOption$/$ConfigName$/include'
        }

        If (.UseConfigDependentInputPath)
        {
            ^CompilerInputPath + '/$ConfigName$'
        }

        .CompilerOutputPath = '$IntermediateDirectory$/$Name$/$ConfigName$'
    ]

	Using(.LocalObjectList)

	If(.ObjectListName not in .Targets)
	{
        ^ReturnValues = { }
        AddUnities(.LocalObjectList)

		Print('AddObjectList:$ObjectListName$')
        PrintArray('AddObjectList:PrebuildDependencies:' .PreBuildDependencies)
		ObjectList('$ObjectListName$') {}
        ^Targets + .ObjectListName
	}

    ^ReturnValues = { '$ObjectListName$' }
}

function AddLibrary(.Library .CompilerConfig)
{
    .LocalLibrary = 
    [
        Using(.Library)
        Using(.CompilerConfig)

        .LibraryName = '$Name$-lib-$ConfigName$'

        ForEach(.Task in .DependencyTasks)
        {
            ^ReturnValues = { }
            AddTask(.Task .CompilerConfig)
            ^PreBuildDependencies + .ReturnValues
        }

        .CompilerOptions + ' -DPROFILING_ENABLED=$ProfilingEnabled$'
            + .LibraryCompilerOptions

        ForEach(.CompilerOption in .ConfigDependentCompilerOptions)
        {
            ^CompilerOptions + '$CompilerOption$/$ConfigName$'
            ^CompilerOptions + '$CompilerOption$/$ConfigName$/include'
        }

        If (.UseConfigDependentInputPath)
        {
            ^CompilerInputPath + '/$ConfigName$'
        }

        .CompilerOutputPath = '$IntermediateDirectory$/$Name$/$ConfigName$'

        .LibrarianOutput = '$OutputDirectory$/$ConfigName$/$OutputFilePrefix$$Name$$OutputFileSuffix$'
    ]

	Using(.LocalLibrary)

    If(.LibraryName not in .Targets)
	{
        ^ReturnValues = { }
        AddUnities(.LocalLibrary)

        Print('AddLibrary:$LibraryName$')
        PrintArray('AddLibrary:PrebuildDependencies:' .PreBuildDependencies)
		Library('$LibraryName$') {}
        ^Targets + .LibraryName
	}

    ^ReturnValues = { '$LibraryName$' }
}

function AddDLL(.DLL .CompilerConfig)
{
    .LocalDLL = 
    [
        Using(.DLL)
        Using(.CompilerConfig)

        .DLLName = '$Name$-dll-$ConfigName$'

        .LinkerOptions + .DLLLinkerOptions
        .LinkerOutput = '$OutputDirectory$/$ConfigName$/$OutputFilePrefix$$Name$$OutputFileSuffix$'
    ]

	Using(.LocalDLL)

    If(.DLLName not in .Targets)
	{
		ForEach(.ObjectList in .DependencyObjectLists)
		{
            ^ReturnValues = { }
            AddObjectList(.ObjectList .CompilerConfig)
            ^Libraries + .ReturnValues
        }

		ForEach(.Library in .DependencyLibraries)
		{
            ^ReturnValues = { }
            AddLibrary(.Library .CompilerConfig)
            ^Libraries + .ReturnValues
        }

		Print('AddDLL:$DLLName$')
        PrintArray('AddDLL:Libraries:' .Libraries)
        PrintArray('AddDLL:PrebuildDependencies:' .PreBuildDependencies)
		DLL('$DLLName$') {}
        ^Targets + .DLLName
	}

    ^ReturnValues = { '$DLLName$' }
}

function AddExecutable(.Executable .CompilerConfig)
{
    .LocalExecutable = 
    [
        Using(.Executable)
        Using(.CompilerConfig)

        .ExecutableName = '$Name$-exe-$ConfigName$'

        .LinkerOptions + .ExecutableLinkerOptions
        .LinkerOutput = '$BuildOutputPath$/$ConfigName$/$Name$$OutputFileSuffix$'
    ]

	Using(.LocalExecutable)

    If(.ExecutableName not in .Targets)
	{
		ForEach(.ObjectList in .DependencyObjectLists)
		{
            ^ReturnValues = { }
            AddObjectList(.ObjectList .CompilerConfig)
            ^Libraries + .ReturnValues
		}

		ForEach(.Library in .DependencyLibraries)
		{
            ^ReturnValues = { }
            AddLibrary(.Library .CompilerConfig)
            ^Libraries + .ReturnValues
		}

		ForEach(.DLL in .DependencyDLLs)
		{
            ^ReturnValues = { }
            AddDLL(.DLL .CompilerConfig)
            ^Libraries + .ReturnValues
		}

		Print('AddExecutable:$ExecutableName$')
        PrintArray('AddExecutable:Libraries:' .Libraries)
        PrintArray('AddExecutable:PrebuildDependencies:' .PreBuildDependencies)
		Executable('$ExecutableName$') {}
        ^Targets + .ExecutableName
	}

    ^ReturnValues = { '$ExecutableName$' }
}

function AddTest(.Test .CompilerConfig)
{
    .LocalTest = 
    [
        Using(.Test)
        Using(.CompilerConfig)

        .TestName = '$Name$-test-$ConfigName$'
                
        If (.TestWorkingDir == .EmptyString)
        {
            ^TestWorkingDir = '$IntermediateDirectory$/$Name$/$ConfigName$'
        }

        .TestExecutable = '$Name$-exe-$ConfigName$'
        .TestOutput = '$IntermediateDirectory$/$Name$/$ConfigName$/$TestOutputName$'
    ]

	Using(.LocalTest)

    If(.TestName not in .Targets)
	{
        ForEach(.Executable in .DependencyExecutables)
        {
            ^ReturnValues = { }
            AddExecutable(.Executable .CompilerConfig)
        }
        
		Print('AddTest:$TestName$')
        PrintArray('AddTest:PrebuildDependencies:' .PreBuildDependencies)
	 	Test('$TestName$') {}
        ^Targets + .TestName
	}

    ^ReturnValues = { '$TestName$' }
}

function AddTask(.Task .CompilerConfig)
{
    .LocalTask = 
    [
        Using(.Task)
        Using(.CompilerConfig)

        .TaskName = '$Name$-task-$ConfigName$'
        
        If (.ExecOutputName == .EmptyString)
        {
            ^ExecOutputName = '$Name$'
        }

        If (.ExecExecutable == .EmptyString)
        {
            ^ExecExecutable = '$Name$-exe-$ConfigName$'
        }

        If (.ExecWorkingDir == .EmptyString)
        {
            ^ExecWorkingDir = '$IntermediateDirectory$/$Name$/$ConfigName$'
        }

        .ExecOutput = '$IntermediateDirectory$/$Name$/$ConfigName$/$ExecOutputName$'
    ]

	Using(.LocalTask)

    If(.TaskName not in .Targets)
	{
        ForEach(.Executable in .DependencyExecutables)
        {
            ^ReturnValues = { }
            AddExecutable(.Executable .CompilerConfig)
        }

		Print('AddTask:$TaskName$')
        PrintArray('AddTask:PrebuildDependencies:' .PreBuildDependencies)
	 	Exec('$TaskName$') {}
        ^Targets + .TaskName
	}

    ^ReturnValues = { '$TaskName$' }
}

function AddProjectConfig(.ArchitectureName .CompilerConfig)
{
    .LocalProjectConfig = 
    [
        Using(.CompilerConfig)

        .Platform = .ArchitectureName
        .Config = .ConfigName
        .ProjectConfigName = '$Config$_$Platform$'
    ]

    Using(.LocalProjectConfig)

    If(.ProjectConfigName not in .Targets)
	{
		Print('AddProjectConfig:$ProjectConfigName$')
        ^ProjectConfigs + .LocalProjectConfig
	}

    ^ReturnValues = { '$ProjectConfigName$' }
}

function AddProject(.Project .AllProjectConfigs)
{
    .LocalProject = 
    [
        Using(.Project)

        .ProjectName = '$Name$-$ProjectType$'
        .ProjectInputPaths = .CompilerInputPath
        // .ProjectInputPathsExclude       // (optional) Paths to exclude from project
        // .ProjectPatternToExclude        // (optional) Pattern(s) for files to exclude from project
        // .ProjectAllowedFileExtensions   // (optional) Extensions to allow in path searches
        .ProjectFiles = .CompilerInputFiles
        // .ProjectFilesToExclude          // (optional) List of files to exclude from project
        // .ProjectBasePath                // (optional) Base path(s) for root folder(s) in project
        .ProjectOutput = '$BuildRootPath$/$ProjectName$.vcxproj'
        .Output = '$BuildOutputPath$/^$(Configuration)/$OutputFilePrefix$$Name$$OutputFilePrefix$'
        .ProjectConfigs = .AllProjectConfigs
    ]

    Using(.LocalProject)

    // .SolutionDependency = 
    // [
    //      Using(.Project)
    //     .Projects = { '$ProjectName$' }
    //     .Dependencies = { .Dependencies }
    // ]
    
    // .SolutionFolder = 
    // [
    //      Using(.Project)
    //     .Path = '$Name$'
    //     .Projects = { '$ProjectName$' }
    // ]

    //^SolutionDependencies + .SolutionDependency
    //^SolutionFolders + .SolutionFolder

    If(.ProjectName not in .Targets)
	{
        ForEach(.ObjectList in .DependencyObjectLists)
		{
            ^ReturnValues = { }
            AddProject(.ObjectList .AllProjectConfigs)
            //^Dependencies + .ReturnValues
		}

		ForEach(.Library in .DependencyLibraries)
		{
            ^ReturnValues = { }
            AddProject(.Library .AllProjectConfigs)
            //^Dependencies + .ReturnValues
		}

		ForEach(.DLL in .DependencyDLLs)
		{
            ^ReturnValues = { }
            AddProject(.DLL .AllProjectConfigs)
            //^Dependencies + .ReturnValues
		}

		Print('AddProject:$ProjectName$')
        VCXProject('$ProjectName$') {}
        ^Targets + .ProjectName
	}

    If(.ProjectName not in .ProjectNames)
	{
        ^ProjectNames + .ProjectName
	}

    ^ReturnValues = { '$ProjectName$' }
}

function AddSolution(.Name .AllProjectConfigs .AllProjectNames)
{
    .LocalSolution = 
    [
        .SolutionName = '$Name$'
        .SolutionOutput = '$BuildRootPath$/$Name$.sln'
        .SolutionProjects = .AllProjectNames
        .SolutionConfigs = .AllProjectConfigs
        //.SolutionFolders = .AllSolutionFolders
        //.SolutionDependencies = .AllSolutionDependencies
        //.SolutionVisualStudioVersion        // (optional) Version of Solution (default "14.0.22823.1" VS2015 RC)
        //.SolutionMinimumVisualStudioVersion // (optional) Min version of Solution (default "10.0.40219.1" VS2010 Express)
        .SolutionBuildProject = 'all-vcxproj'
        //.SolutionDeployProjects             // (optional) Project(s) set deploy
    ]

    Using(.LocalSolution)
    
    If(.SolutionName not in .Targets)
	{
        PrintArray('AddSolution:SolutionProjects:' .SolutionProjects)
        Print('AddSolution:$SolutionName$')
        VSSolution('$SolutionName$') {}
        ^Targets + .SolutionName
    }

    ^ReturnValues = { '$SolutionName$' }
}
